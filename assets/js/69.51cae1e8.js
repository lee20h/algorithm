(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{494:function(A,a,t){"use strict";t.r(a);var s=t(25),l=Object(s.a)({},(function(){var A=this,a=A.$createElement,t=A._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":A.$parent.slotKey}},[t("h1",{attrs:{id:"dynamic-memory-allocation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-memory-allocation"}},[A._v("#")]),A._v(" Dynamic Memory Allocation")]),A._v(" "),t("h2",{attrs:{id:"memory-allocation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-allocation"}},[A._v("#")]),A._v(" Memory Allocation")]),A._v(" "),t("h3",{attrs:{id:"volatile-and-non-volatile-storage-devices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile-and-non-volatile-storage-devices"}},[A._v("#")]),A._v(" Volatile and Non-volatile storage devices")]),A._v(" "),t("ul",[t("li",[t("strong",[A._v("Primary storage: Main memory")]),A._v(" "),t("ul",[t("li",[A._v("주기억장치로 사용하는 DRAM 등의 휘발성 저장 장치")]),A._v(" "),t("li",[A._v("성능이 높지만, 적은 저장 공간 제공\n"),t("ul",[t("li",[t("strong",[A._v("프로그램 내의 변수와 같이 용량은 적지만 자주 접근하는 자료를 저장")])])])])])]),A._v(" "),t("li",[A._v("Secondary storage: Storage devices\n"),t("ul",[t("li",[A._v("보조기억장치로 사용하는 HDD, SSD 등은 비휘발성 저장 장치")]),A._v(" "),t("li",[A._v("느리지만, 많은 저장 공간을 제공\n"),t("ul",[t("li",[A._v("시스템 종료 시에도 보관하여야 할 데이터를 적재하고, 시스템 재기동 시 다시 로드")])])]),A._v(" "),t("li",[A._v("일반적으로 파일(file)의 형태로 데이터를 저장함")])])])]),A._v(" "),t("h3",{attrs:{id:"memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory"}},[A._v("#")]),A._v(" Memory")]),A._v(" "),t("ul",[t("li",[A._v("메모리는 한정된 자원 (예. 8GB, 16GB)\n"),t("ul",[t("li",[A._v("OS와 여러 프로세스가 동시에 물리 메모리 공간을 공유하며 실행됨")]),A._v(" "),t("li",[A._v("OS는 자기 자신과 여러 프로세스에 대해 최대한 효율적으로 메모리를 할당하고자 함\n"),t("ul",[t("li",[A._v("이를 위해 OS는 가상 메모리 관리 기법을 사용")])])])])]),A._v(" "),t("li",[A._v("가상 메모리 공간 (Virtual Memory Space)\n"),t("ul",[t("li",[A._v("각 프로세스는 자기 자신만의 독립되고, 고립된 (isolated) 메모리 공간을 가짐\n"),t("ul",[t("li",[A._v("프로세스들은 서로 다른 사람의 space 를 건드릴 수 없음!")]),A._v(" "),t("li",[A._v("공간의 크기는? 일반적으로 32 비트 주소 공간 (각 주소 마다 1B 저장: total 4GB = 2^32)\n"),t("ul",[t("li",[A._v("64비트 프로세스의 경우, 48비트 혹은 56 비트만 사용 (256 TB = 2^48 or 64 PB = 2^56)")])])])])])])])]),A._v(" "),t("h3",{attrs:{id:"memory-allocation-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#memory-allocation-2"}},[A._v("#")]),A._v(" Memory Allocation")]),A._v(" "),t("ul",[t("li",[t("p",[A._v("OS의 메모리 관리")]),A._v(" "),t("ul",[t("li",[A._v("OS는 해당 “가상” 메모리 공간에 대해 필요할 때만, 필요한 만큼만 실제 물리 메모리를 할당해 줌 (짠돌이)")]),A._v(" "),t("li",[A._v("예) 호텔을 예약하는데, 일단 100개 객실이 있는 호텔을 통째로 다 빌려준다고 말함\n"),t("ul",[t("li",[A._v("실제 객실은 100개일수도 있고, 200개 일수도 있고, 10개일수도 있음!")])])]),A._v(" "),t("li",[A._v("Private hotel~! You are our only guest!\n"),t("ul",[t("li",[A._v("거짓말 이지만 진짜! 실제로 다른 손님과 절대 만나는 일이 없도록 관리해 줌")])])]),A._v(" "),t("li",[A._v("딴 사람한테도 그렇게 예약해줌 (over-booking)")]),A._v(" "),t("li",[t("strong",[A._v("실제로 손님이 왔을 때에, 실제 객실을 나눠 줌")])]),A._v(" "),t("li",[A._v("만약 실제 객실 수보다 많이 오면?\n"),t("ul",[t("li",[A._v("객실 손님이 자고 있을 때, 슬쩍 방 전체를 아주 아주 넓은 창고로 옮김 (Secondary storage)")]),A._v(" "),t("li",[A._v("해당 객실에 새 손님을 받음")])])]),A._v(" "),t("li",[A._v("창고 용량도 넘어가면??? OOM!! (Out-Of-Memory)\n"),t("ul",[t("li",[A._v("호텔 문 닫고 다 내쫓음 (프로세스 강제 종료)")])])])])]),A._v(" "),t("li",[t("p",[A._v("따라서 실제로 메모리 공간을 사용할 때는, OS에게 메모리 할당을 요청해야 함")])]),A._v(" "),t("li",[t("p",[A._v("OS는 두 가지 방식으로 메모리 할당을 수행함: Static and Dynamic")])]),A._v(" "),t("li",[t("p",[A._v("Static (정적 할당)")]),A._v(" "),t("ul",[t("li",[A._v("프로그램이 수행되어 새로운 프로세스를 생성하는 과정에서 메모리를 할당하고, 해당 프로세스가 종료되기 이전까지는 할당이 해제되거나 내용이 변경되지 않음")]),A._v(" "),t("li",[A._v("사용할 메모리 공간의 크기를 정하는 주체: 컴파일러\n"),t("ul",[t("li",[A._v("프로그램이 실행되기 이전에 컴파일러에 의해 변수의 저장 공간 크기가 정해짐")])])]),A._v(" "),t("li",[A._v("대상 자료 형태: 변수, 배열, 구조체로 선언된 자료들\n"),t("ul",[t("li",[A._v("예) "),t("code",[A._v("int i")]),A._v("; 로 선언하고 나면, 실제 수행 중에 그 크기와 저장 위치를 변경하는 것은 불가능")])])]),A._v(" "),t("li",[A._v("단점: 실행 이전에 사용할 메모리의 공간 크기가 정해진다는 건?\n"),t("ul",[t("li",[A._v("예) struct friend list[10]; 카톡에서 친구 10명에 관한 구조체 데이터를 저장하기 위한 배열")]),A._v(" "),t("li",[A._v("만약 10명 이상이면? → 소스 코드를 고치고, 새로 컴파일하고, 새로 수행해야 함")]),A._v(" "),t("li",[A._v("넉넉하게 한 100만명 잡으면? → 실제 사용량에 비해 너무 많은 메모리를 할당해 비효율적")]),A._v(" "),t("li",[t("strong",[A._v("메모리 사용량 예측이 부정확한 경우, 정보 저장에 실패하거나 메모리를 낭비하게 됨")])])])])])]),A._v(" "),t("li",[t("p",[t("strong",[A._v("필요할 때, 필요한 만큼 메모리 공간을 할당하고, 필요없을 때는 해제하고 싶다!")])]),A._v(" "),t("ul",[t("li",[A._v("OS and neighbors: “Good!!”")])])]),A._v(" "),t("li",[t("p",[A._v("Dynamic (동적 할당)")]),A._v(" "),t("ul",[t("li",[A._v("프로세스의 실행 중에 필요한 메모리를 할당하는 방법\n"),t("ul",[t("li",[A._v("CS에서 Dynamic 이란 용어는 “프로세스의 실행 중” 으로 해석하면 됨")])])]),A._v(" "),t("li",[A._v("메모리 사용 예측이 정확하지 않고 실행 중에 메모리 할당이 필요할 때 사용")]),A._v(" "),t("li",[A._v("예) 카톡 친구가 한 명 추가될 때 마다,\n"),t("ul",[t("li",[A._v("해당 친구의 정보를 저장하기 위해,")]),A._v(" "),t("li",[A._v("메모리 공간을 필요한 만큼만 추가로 할당받아 저장한다.")]),A._v(" "),t("li",[A._v("그리고 친구 삭제하면 해당 공간을 할당 해제 (deallocation or free) 하여 OS에게 되돌려준다.")])])]),A._v(" "),t("li",[A._v("단점: 사용이 (아주 약간) 불편함\n"),t("ul",[t("li",[A._v("메모리를 매번 명시적으로 할당/해제 해야 함\n"),t("ul",[t("li",[A._v("필요한 메모리 양을 계산하고, 시스템콜을 사용하여 OS에 요청")])])]),A._v(" "),t("li",[A._v("포인터의 사용이 필요함\n"),t("ul",[t("li",[A._v("새로 할당받은 메모리 공간을 지칭하기 위함")]),A._v(" "),t("li",[A._v("포인터가 없는 언어에서도 동적 할당은 필수적이며, 다양한 형태로 지원 (예. Java의 ArrayList)")])])])])])])])]),A._v(" "),t("h3",{attrs:{id:"메모리-할당-영역"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리-할당-영역"}},[A._v("#")]),A._v(" 메모리 할당 영역")]),A._v(" "),t("ul",[t("li",[A._v("Code (text)\n"),t("ul",[t("li",[A._v("프로그램 코드가 복제되어 실행에 사용")])])]),A._v(" "),t("li",[A._v("Data\n"),t("ul",[t("li",[A._v("Global and static local variables")])])]),A._v(" "),t("li",[A._v("Heap\n"),t("ul",[t("li",[A._v("동적으로 할당받은 메모리가 위치함")]),A._v(" "),t("li",[A._v("동적 메모리 할당의 요청/해제에 따라, 늘어나거나 줄어듦")])])]),A._v(" "),t("li",[A._v("Stack\n"),t("ul",[t("li",[A._v("함수 호출에 따라 동적으로 변경되는 부분")]),A._v(" "),t("li",[A._v("Function call 에 따라 스택이 쌓이면서 늘어나고, return 에 의해 다시 줄어듦")]),A._v(" "),t("li",[A._v("지역 변수 (local variable), 함수 호출에 따른 인자 등이 저장됨")])])]),A._v(" "),t("li",[A._v("Code and data: 프로세스가 실행될 때, 크기가 정해지고 변하지 않음")]),A._v(" "),t("li",[A._v("Heap and stack: 프로세스의 수행에 따라 계속 크기가 변경됨")])]),A._v(" "),t("h2",{attrs:{id:"dynamic-memory-allocation-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-memory-allocation-2"}},[A._v("#")]),A._v(" Dynamic Memory Allocation")]),A._v(" "),t("h3",{attrs:{id:"동적-메모리-관련-함수"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#동적-메모리-관련-함수"}},[A._v("#")]),A._v(" 동적 메모리 관련 함수")]),A._v(" "),t("ul",[t("li",[t("p",[A._v("동적 메모리")]),A._v(" "),t("ul",[t("li",[A._v("함수 "),t("code",[A._v("malloc()")]),A._v("의 호출로 힙(heap) 영역에 확보")]),A._v(" "),t("li",[A._v("메모리는 사용 후 함수 "),t("code",[A._v("free()")]),A._v("를 사용해 해제")]),A._v(" "),t("li",[A._v("만일 메모리 해제를 하지 않으면, 메모리 부족과 같은 문제를 일으킬 수 있으니, 꼭 해제하는 습관을 가질 것")])])]),A._v(" "),t("li",[t("p",[A._v("동적 메모리 할당 함수: "),t("code",[A._v("malloc()")]),A._v(", "),t("code",[A._v("calloc()")]),A._v(", "),t("code",[A._v("realloc()")]),A._v(" 3가지")]),A._v(" "),t("ul",[t("li",[A._v("Return type: void *\n"),t("ul",[t("li",[A._v("Void 형: 특정한 형태가 없음을 뜻함")]),A._v(" "),t("li",[A._v("메모리에 적재할 자료의 포인터 형으로 변환(casting)해서 사용\n"),t("ul",[t("li",[A._v("예) "),t("code",[A._v("int *data = (int *) malloc(sizeof(int));")])])])])])]),A._v(" "),t("li",[A._v("헤더파일 stdlib.h 필요")])])]),A._v(" "),t("li",[t("p",[A._v("동적으로 할당된 메모리를 해제하여 반환")]),A._v(" "),t("ul",[t("li",[A._v("함수 "),t("code",[A._v("free()")])])])])]),A._v(" "),t("table",[t("thead",[t("tr",[t("th",[A._v("메모리")]),A._v(" "),t("th",[A._v("함수 원형")]),A._v(" "),t("th",[A._v("기능")])])]),A._v(" "),t("tbody",[t("tr",[t("td",[A._v("메모리 할당 (기본값 없이)")]),A._v(" "),t("td",[A._v("void * malloc(size_t)")]),A._v(" "),t("td",[A._v("인자만큼의 메모리 할당 후 기본 주소 반환")])]),A._v(" "),t("tr",[t("td",[A._v("메모리 할당 (기본값 0으로)")]),A._v(" "),t("td",[A._v("void * calloc(size_t, size_t)")]),A._v(" "),t("td",[A._v("뒤 인자 만큼의 메모리 크기로 앞 인자 수 만큼 할당 후 기본 주소 반환")])]),A._v(" "),t("tr",[t("td",[A._v("기존 메모리 변경 (이전값 그대로)")]),A._v(" "),t("td",[A._v("void * realloc(void *, size_t)")]),A._v(" "),t("td",[A._v("앞 인자의 메모리를 뒤 인자 크기로 변경 후, 기본 주소 반환")])]),A._v(" "),t("tr",[t("td",[A._v("메모리 해제")]),A._v(" "),t("td",[A._v("void free(void *)")]),A._v(" "),t("td",[A._v("인자를 기본 주소로 갖는 메모리 해제")])])])]),A._v(" "),t("h3",{attrs:{id:"메모리-할당-malloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리-할당-malloc"}},[A._v("#")]),A._v(" 메모리 할당: malloc()")]),A._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("pi "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token function"}},[A._v("malloc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("sizeof")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("pi "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[A._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n")])])]),t("ul",[t("li",[A._v("할당 이후, 간접연산자 *pi를 이용하여 원하는 값을 수정 가능\n"),t("ul",[t("li",[A._v("이때 "),t("code",[A._v("malloc()")]),A._v("으로 할당받은 메모리 공간에 적재된 값이 변경되는 것")])])]),A._v(" "),t("li",[A._v("pi를 다른 메모리 공간의 주소로 수정 가능\n"),t("ul",[t("li",[A._v("기존 메모리 공간은?")]),A._v(" "),t("li",[A._v("해당 주소를 알아야 "),t("code",[A._v("free()")]),A._v(" 를 할 수 있으므로, 이렇게 유실되는 경우가 없어야 함")])])])]),A._v(" "),t("h3",{attrs:{id:"메모리-해제-free"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리-해제-free"}},[A._v("#")]),A._v(" 메모리 해제: free()")]),A._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[A._v("free")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),A._v("pi"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n")])])]),t("ul",[t("li",[A._v("free(pi)\n"),t("ul",[t("li",[A._v("함수 malloc()의 반환 주소를 저장한 변수 pi를 해제\n"),t("ul",[t("li",[A._v("인자로 해제할 메모리 공간의 주소값을 갖는 포인터를 이용하여 호출")])])]),A._v(" "),t("li",[A._v("변수 pi가 가리키는 4바이트의 자료값이 해제되어 더 이상 사용할 수 없음")])])])]),A._v(" "),t("h3",{attrs:{id:"메모리-할당-calloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리-할당-calloc"}},[A._v("#")]),A._v(" 메모리 할당: calloc()")]),A._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("ary "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[A._v("NULL")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\nary "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token function"}},[A._v("calloc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[A._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(",")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("sizeof")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n")])])]),t("ul",[t("li",[A._v("할당받은 공간을 0으로 초기화해줌\n"),t("ul",[t("li",[A._v("기존 공간에 저장된 쓰레기 값으로 인한 예측하지 못한 문제를 예방")])])]),A._v(" "),t("li",[A._v("인터페이스의 변경\n"),t("ul",[t("li",[A._v("마치 고수준 I/O 의 "),t("code",[A._v("fread()")]),A._v("/"),t("code",[A._v("fwrite()")]),A._v(" 처럼,")]),A._v(" "),t("li",[A._v("(자료의 개수, 자료 크기) 로 구성되어, 조금 더 편리한 인터페이스 제공")]),A._v(" "),t("li",[A._v("예) "),t("code",[A._v("malloc()")]),A._v(" 에서는 그냥 3 * "),t("code",[A._v("sizeof(int)")]),A._v(" 로 전달")])])])]),A._v(" "),t("h3",{attrs:{id:"메모리-할당-realloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메모리-할당-realloc"}},[A._v("#")]),A._v(" 메모리 할당: realloc()")]),A._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("reary"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(",")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("cary"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\ncary "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token function"}},[A._v("calloc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[A._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(",")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("sizeof")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\nreary "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("=")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token function"}},[A._v("realloc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),A._v("cary"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(",")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[A._v("4")]),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("sizeof")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n")])])]),t("ul",[t("li",[A._v("이미 확보한 저장공간을 새로운 크기로 변경\n"),t("ul",[t("li",[A._v("함수 realloc()에 의하여 다시 확보하는 영역\n"),t("ul",[t("li",[A._v("기존의 영역을 이용하여 그 저장 공간을 변경하는 것이 원칙\n"),t("ul",[t("li",[A._v("새로운 영역을 다시 할당하여 이전의 값을 복사할 수도 있음")])])]),A._v(" "),t("li",[A._v("성공적으로 메모리를 할당하면 변경된 저장공간의 시작 주소를 반환\n"),t("ul",[t("li",[A._v("실패하면 NULL을 반환")])])]),A._v(" "),t("li",[A._v("인자\n"),t("ul",[t("li",[A._v("첫 인자: 변경할 저장공간의 주소\n"),t("ul",[t("li",[A._v("NULL 을 주면, 그냥 malloc()과 동일하게 동작")])])]),A._v(" "),t("li",[A._v("두 번째 인자: 변경하고 싶은 저장공간의 총 크기")])])])])])])])]),A._v(" "),t("h3",{attrs:{id:"useful-c-macros-for-debug-messages"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useful-c-macros-for-debug-messages"}},[A._v("#")]),A._v(" Useful C macros for debug messages")]),A._v(" "),t("ul",[t("li",[t("code",[A._v("__FILE__")]),A._v(" "),t("ul",[t("li",[A._v("소스 파일 명을 출력")]),A._v(" "),t("li",[A._v("컴파일러에 전달된 파일 이름에 따라, 절대 경로가 출력될 수 있음")])])]),A._v(" "),t("li",[t("code",[A._v("__LINE__")]),A._v(" "),t("ul",[t("li",[A._v("현재 라인 번호를 출력")])])]),A._v(" "),t("li",[t("code",[A._v("__func__")]),A._v(" "),t("ul",[t("li",[A._v("함수 이름을 출력")]),A._v(" "),t("li",[t("code",[A._v("__FUNCTION__")]),A._v(" 이라는 동일한 기능의 매크로도 있으나, C 표준이 아니고, 몇몇 컴파일러에서 지원 (__func__는 C99)")])])])]),A._v(" "),t("h2",{attrs:{id:"linked-list-basic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linked-list-basic"}},[A._v("#")]),A._v(" Linked List: Basic")]),A._v(" "),t("h3",{attrs:{id:"연결-리스트"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#연결-리스트"}},[A._v("#")]),A._v(" 연결 리스트")]),A._v(" "),t("ul",[t("li",[A._v("연결 리스트\n"),t("ul",[t("li",[A._v("순차적 자료 표현에 적합한 구조")]),A._v(" "),t("li",[A._v("동적으로 항목이 추가되고, 항목 간의 순서가 변경되는 데이터의 관리에 적합")])])]),A._v(" "),t("li",[A._v("배열과의 비교\n"),t("ul",[t("li",[A._v("컴파일 시 배열의 크기가 이미 결정되어, 실행 중간에 배열 크기 수정이 불가능")]),A._v(" "),t("li",[A._v("순서 변경의 어려움\n"),t("ul",[t("li",[A._v("맨 앞이나 중간에 새로운 항목이 삽입되면?\n"),t("ul",[t("li",[A._v("삽입되는 항목 이후의 이미 저장된 항목들을 모두 뒤로 이동?")]),A._v(" "),t("li",[A._v("많은 양의 데이터 복사로 수행 속도 저하")])])]),A._v(" "),t("li",[A._v("중간에 하나 삭제하는 경우도 마찬가지")])])])])])]),A._v(" "),t("h3",{attrs:{id:"연결-리스트-구조"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#연결-리스트-구조"}},[A._v("#")]),A._v(" 연결 리스트 구조")]),A._v(" "),t("ul",[t("li",[A._v("연결 리스트 기본 구조\n"),t("ul",[t("li",[A._v("헤드에서 시작하여 가리키는 곳을 계속 따라가면 순차적 자료를 표현")])])]),A._v(" "),t("li",[A._v("연결 리스트 예\n"),t("ul",[t("li",[A._v("헤드(head)는 “미수”를 가리키고\n"),t("ul",[t("li",[A._v("“미수”는 다시 “현순”을 가리키고\n"),t("ul",[t("li",[A._v("계속해서 “윤원”, “현화”, “수성”, “나혜”")]),A._v(" "),t("li",[A._v("그리고 다시 나혜는 마지막이라 가리키는 사람이 없는 것(NULL)과 같은 구조")])])])])])])])]),A._v(" "),t("p",[t("img",{staticStyle:{"min-width":"100px","min-height":"100px",background:"url(data:image/gif;base64,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) no-repeat center","background-size":"30px 30px"},attrs:{src:"https://user-images.githubusercontent.com/59367782/99241795-b0418000-2841-11eb-86d4-428bd831b129.png",alt:"image",loading:"lazy"}})]),A._v(" "),t("h3",{attrs:{id:"연결-리스트-구조-노드"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#연결-리스트-구조-노드"}},[A._v("#")]),A._v(" 연결 리스트 구조: 노드")]),A._v(" "),t("ul",[t("li",[A._v("연결 리스트 내의 각 항목은 “Node” 라는 형태로 구성")]),A._v(" "),t("li",[A._v("노드의 자료: 필요한 여러 변수의 조합으로 구성\n"),t("ul",[t("li",[A._v("노드 간의 링크: "),t("strong",[A._v("자기 참조 구조체의 포인터로 구현")])])])]),A._v(" "),t("li",[A._v("Head : 항상 첫 번째 노드를 가리키는 포인터")]),A._v(" "),t("li",[A._v("Tail : 마지막 노드를 가리키는 포인터")])]),A._v(" "),t("h3",{attrs:{id:"연결-리스트-구조-자기-참조-구조체"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#연결-리스트-구조-자기-참조-구조체"}},[A._v("#")]),A._v(" 연결 리스트 구조: 자기 참조 구조체")]),A._v(" "),t("ul",[t("li",[A._v("자기참조 구조체(self reference struct)\n"),t("ul",[t("li",[A._v("구조체의 멤버 중의 하나가 자기 자신의 구조체 포인터 변수를 갖는 구조체")])])])]),A._v(" "),t("div",{staticClass:"language-cpp extra-class"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("struct")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[A._v("selfref")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("{")]),A._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("int")]),A._v(" n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[A._v("struct")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[A._v("selfref")]),A._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[A._v("*")]),A._v("next"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v(";")]),A._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[A._v("}")]),A._v("\n")])])]),t("ul",[t("li",[A._v("구조체 selfref\n"),t("ul",[t("li",[A._v("멤버로 int 형 n과 struct selfref * 형 next로 구성\n"),t("ul",[t("li",[A._v("즉, 멤버 next의 자료형은 지금 정의하고 있는 구조체의 포인터 형")])])]),A._v(" "),t("li",[A._v("구조체 selfref는 자기 참조 구조체\n"),t("ul",[t("li",[A._v("구조체의 멤버 중의 하나가 자기 자신의 구조체 포인터 변수")])])]),A._v(" "),t("li",[A._v("구조체는 자기 자신 포인터를 멤버로 사용할 수 있으나\n"),t("ul",[t("li",[A._v("자기 자신은 멤버로 사용 불가능: 재귀적 참조로 인해 크기를 결정할 수 없음")])])])])])]),A._v(" "),t("h3",{attrs:{id:"연결-리스트의-장단점"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#연결-리스트의-장단점"}},[A._v("#")]),A._v(" 연결 리스트의 장단점")]),A._v(" "),t("ul",[t("li",[t("p",[A._v("연결 리스트 장점")]),A._v(" "),t("ul",[t("li",[A._v("항목 수를 프로그램 내부에서 메모리가 허용하는 한 늘릴 수 있다는 것\n"),t("ul",[t("li",[A._v("배열과는 달리 프로그램 실행 전에 미리 기억장소를 확보해 둘 필요가 없음")])])]),A._v(" "),t("li",[A._v("프로그램 실행 중이라도 필요할 때 노드를 동적으로 생성\n"),t("ul",[t("li",[A._v("기존의 연결 리스트에 삽입 또는 추가 가능")])])]),A._v(" "),t("li",[A._v("항목 들이 메모리 공간에 연속적으로 저장될 필요가 없음\n"),t("ul",[t("li",[A._v("중간에 노드를 삽입 또는 삭제하더라도 배열에 비하여 다른 노드에 영향을 적게 미침")])])]),A._v(" "),t("li",[A._v("결론적으로 연결 리스트는 동적으로 노드를 생성하고 관리함으로써,\n"),t("ul",[t("li",[A._v("리스트 크기의 증가 감소에 따라 효율적으로 대처할 수 있으며")]),A._v(" "),t("li",[A._v("노드의 삽입과 삭제와 같은 자료의 재배치를 빠르게 처리")])])])])]),A._v(" "),t("li",[t("p",[A._v("단점: random access")]),A._v(" "),t("ul",[t("li",[A._v("배열에 비하여 임의 접근(random access)에 많은 시간이 소용")]),A._v(" "),t("li",[A._v("노드 검색은 헤드에서부터 링크를 따라가는 순차적 검색만이 가능")])])])]),A._v(" "),t("h3",{attrs:{id:"노드-순회-node-traversal"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#노드-순회-node-traversal"}},[A._v("#")]),A._v(" 노드 순회(node traversal)")]),A._v(" "),t("ul",[t("li",[A._v("노드 순회(node traversal)\n"),t("ul",[t("li",[A._v("연결 리스트에서 모든 노드를 순서대로 참조하는 방법")]),A._v(" "),t("li",[A._v("헤드부터 계속 노드 링크의 포인터로 이동하면 가능\n"),t("ul",[t("li",[A._v("링크가 NULL이면 마지막 노드")]),A._v(" "),t("li",[A._v("노드 순회 방법을 이용하여 각 노드의 자료를 참조할 수 있음")])])])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);